{"meta":{"title":"Pinohans Blog","subtitle":"","description":"","author":"Pinohans","url":"https://pinohans.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-03-29T09:07:08.785Z","updated":"2023-03-29T09:07:08.785Z","comments":false,"path":"/404.html","permalink":"https://pinohans.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-03-29T09:06:15.909Z","updated":"2023-03-29T09:06:15.909Z","comments":false,"path":"about/index.html","permalink":"https://pinohans.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-03-29T09:07:08.922Z","updated":"2023-03-29T09:07:08.922Z","comments":false,"path":"books/index.html","permalink":"https://pinohans.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-03-29T09:07:09.052Z","updated":"2023-03-29T09:07:09.052Z","comments":false,"path":"categories/index.html","permalink":"https://pinohans.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-03-29T09:07:09.203Z","updated":"2023-03-29T09:07:09.202Z","comments":true,"path":"links/index.html","permalink":"https://pinohans.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-03-29T09:07:09.466Z","updated":"2023-03-29T09:07:09.466Z","comments":false,"path":"tags/index.html","permalink":"https://pinohans.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-03-29T09:07:09.336Z","updated":"2023-03-29T09:07:09.335Z","comments":false,"path":"repository/index.html","permalink":"https://pinohans.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"oauth2攻击面分析","slug":"oauth2攻击面分析","date":"2023-03-29T09:56:30.000Z","updated":"2023-04-03T08:55:30.359Z","comments":true,"path":"2023/03/29/oauth2攻击面分析/","link":"","permalink":"https://pinohans.github.io/2023/03/29/oauth2%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/","excerpt":"","text":"前言随着大量开放平台的出现，建立在开放平台之上的各种第三方应用也在大量涌现，出于对安全性和统一标准的要求，诞生了oauth协议。 OAuth 1.0于2007年推出后迅速被广泛使用。 但是在2009年，OAuth 1.0被曝出存在严重安全漏洞Session Fixation Attack，于同年发布修复后版本OAuth 1.0 Revision A。 2010年发布OAuth 2.0，是OAuth协议的下一版本，但与OAuth 1.0版本互不兼容。 2013年发布PKCE(Proof Key for Code Exchange by OAuth Public Clients)，是OAuth 2.0的一个扩展，用于增强公共客户端的安全性。 2015年发布OAuth 2.0 for Native Apps，是OAuth 2.0的一个扩展，用于增强移动应用的安全性，描述了使用OAuth 2.0的本机和移动应用程序的安全要求和其他建议。包括不允许第三方应用打开嵌入式web视图，以防止钓鱼攻击，以及如何在平台上执行的特定建议。同时还建议使用PKCE扩展进一步保护用户。 2017年发布Security Best Current Practice，是OAuth 2.0的一个扩展，描述了安全要求和其他建议，用于实现OAuth 2.0的客户端和服务器。 2019年发布OAuth 2.0 for Browser-Based Apps，是OAuth 2.0的一个扩展，用于增强浏览器应用的安全性，针对SPA(Single Page Application)建议使用PKCE扩展替代隐式授权流(Implicit flow)。 2021年发布OAuth 2.1，OAuth 2.1总结了后续规范中发布的更改，以简化核心文档。主要区别如下: PKCE是所有使用授权码流的OAuth客户端的必需项 重定向URI必须使用精确字符串匹配进行比较 省略了隐式授权流（response_type &#x3D; token）的定义 省略了资源所有者密码凭证授予的定义 Bearer令牌使用省略了在URI的查询字符串中使用bearer令牌的使用 对于公共客户端，刷新令牌必须是发送者约束的或一次性使用 公共和机密客户端的定义已简化为仅指示客户端是否具有凭据 OAuth 1.0漏洞(Session Fixation Attack)分析 正常流程为： 用户访问第三方应用 用户请求从资源提供者导入资源 用户携带oauth_token跳转到资源提供者的授权页面 用户登录到资源提供者系统 用户授权oauth_token访问资源权限 用户携带oauth_token跳转到return_url指定的第三方应用 第三方应用使用oauth_token请求资源 攻击者可以利用的流程在3、4、5、6步骤 攻击者构造包含oauth_token和无效return_url的URL 让受害者点击链接访问，登录授权后，跳转到无效return_url 此时受害者授权流程已经中断，攻击者可以利用受害者的oauth_token访问第三方应用完成授权 漏洞成因可以总结为，授权码生成方式问题。OAuth1.0中，授权码在请求授权过程中可任意生成，导致授权码可能来自于攻击者。同时授权和令牌获取过程是割裂的，导致攻击者可以优先于受害者获取令牌。 什么是OAuth2OAuth 2.0是一个业界标准的授权协议，其定义了四种可以适用于各种应用场景的授权交互模式： 授权码模式(Authorization Code) 客户端凭证模式(Client Credentials) 用户凭证模式(Resource Owner Password Credentials) 隐式授权模式(Implicit) 其中，授权码模式被广泛应用于第三方互联网开放平台，通过第三方登录是其最常见应用场景之一，比如使用微信、QQ和淘宝账号进行登录。 有一些设备存在无浏览器或输入受限情况，所以在rfc8628 - OAuth 2.0 Device Authorization Grant引入设备授权(Device code)模式。 为了解决SPA、原生应用等授权安全性问题，基于授权码模式引入PKCE，形成授权码+PKCE模式(Authorization Code with PKCE)。 角色OAuth 2.0定义了四种角色： 资源拥有者（Resource Owner）：资源拥有者是指可以授权第三方应用访问自己资源的用户，比如微信用户。 资源服务器（Resource Server）：资源服务器是指存储资源的服务器，比如微信服务器。 客户端（Client）：客户端是指第三方应用，比如京东小程序。 授权服务器（Authorization Server）：授权服务器是指用于进行授权的服务器，比如微信开放平台。 协议流程1234567891011121314151617+--------+ +---------------+| |--(A)- Authorization Request -&gt;| Resource || | | Owner || |&lt;-(B)-- Authorization Grant ---| || | +---------------+| || | +---------------+| |--(C)-- Authorization Grant --&gt;| Authorization || Client | | Server || |&lt;-(D)----- Access Token -------| || | +---------------+| || | +---------------+| |--(E)----- Access Token ------&gt;| Resource || | | Server || |&lt;-(F)--- Protected Resource ---| |+--------+ +---------------+ A. 客户端向资源拥有者发起授权请求，请求授权服务器授予客户端访问资源服务器的权限。 B. 资源拥有者授权客户端访问资源服务器的权限，授权服务器返回授权码给客户端。 C. 客户端向授权服务器请求访问令牌。 D. 授权服务器验证授权码，返回访问令牌给客户端。 E. 客户端向资源服务器请求资源。 F. 资源服务器验证访问令牌，返回资源给客户端。 授权模式仅ABCD流程不同，区分为不同模式。 授权码模式(Authorization Code) 这种模式广泛用于第三方应用授权登录，比如使用微信、QQ账号进行登录。 授权码+PKCE模式(Authorization Code with PKCE)在rfc7636 - Proof Key for Code Exchange by OAuth Public Clients定义了PKCE，用于解决授权码模式存在的安全性问题。 这种模式广泛用于客户端应用授权登录，比如electron应用、移动应用等。 其中： code_verifier：在 [A-Z] / [a-z] / [0-9] / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; 范围内，生成43-128位的随机字符串。 code_challenge：则是对 code_verifier 通过 code_challenge_method 例如 sha256 转换得来的。 Q: PKCE到底防御哪种攻击？ A: 在SPA、原生应用（如移动应用）、桌面应用（如electron）中，授权过程中有可能会打开外部浏览器，而浏览器可能会被其他应用劫持，导致授权过程被篡改。PKCE是为了防御这种攻击。 客户端凭证模式(Client Credentials) 这种模式用于客户端应用存储凭证，自行授权访问资源服务器，比如后端服务使用AK&#x2F;SK请求操作OSS资源。 用户凭证模式(Resource Owner Password Credentials) 不安全 由于凭证会发送给第三方使用，所以这种模式不安全，不推荐使用。 隐式授权模式(Implicit) 不安全 一般用于无后端应用，前端存储凭证。 由于是跳转到三方应用使用GET请求，且服务器直接回传的是授权凭证，在终端容易被读取，如通过资源文件referer，所以这种模式不安全，不推荐使用。 在某篇博客中曾看到，腾讯存在某个服务使用了隐式授权模式，但是回传Access Token的时候，使用锚点（#），这样锚点之后的数据就不会发送给服务器。但是这种方式也存在安全问题，因为锚点之后的数据是可以被前端获取的，所以这种方式也不安全。 设备代码模式(Device Code) 极大概率存在Session Fixation Attack漏洞在rfc8628 - OAuth 2.0 Device Authorization Grant定义了一种新的授权模式，用于设备在无浏览器或输入受限情况下的授权。 1234567891011121314151617181920212223+----------+ +----------------+| |&gt;---(A)-- Client Identifier ---&gt;| || | | || |&lt;---(B)-- Device Code, ---&lt;| || | User Code, | || Device | &amp; Verification URI | || Client | | || | [polling] | || |&gt;---(E)-- Device Code ---&gt;| || | &amp; Client Identifier | || | | Authorization || |&lt;---(F)-- Access Token ---&lt;| Server |+----------+ (&amp; Optional Refresh Token) | | v | | : | | (C) User Code &amp; Verification URI | | : | | v | |+----------+ | || End User | | || at |&lt;---(D)-- End user reviews ---&gt;| || Browser | authorization request | |+----------+ +----------------+ 当Device Client为公共客户端，将退化为OAuth1.0认证方式。 OIDCOpenID Connect 1.0 是 OAuth 2.0 协议的一个简单身份层。它允许客户端基于授权服务器执行的身份验证来验证最终用户的身份，以及以可互操作且类似 REST 的方式获取有关最终用户的基本配置文件信息。 简单来说： 授权码模式：使用response_type&#x3D;code，用授权码换取令牌AccessToken。 OIDC：使用scope&#x3D;openid&amp;response_type&#x3D;code，用授权码换取用于验证身份的JWT。 OAuth2攻击面CSRF导致绑定劫持攻击者抓取认证请求构造恶意url，并诱骗已经登录的网用户点击(比如通过邮件或者QQ等方式)，认证成功后用户的帐号会同攻击者的帐号绑定到一起。 OAuth 2.0提供了state参数用于防御CSRF，认证服务器在接收到的state参数按原样返回给redirect_uri，客户端收到该参数并验证与之前生成的值是否一致，除此方法外也可使用传统的CSRF防御方案。 案例1: 人人网-百度OAuth 2.0 redirect_uir CSRF 漏洞 redirect_uri绕过导致授权劫持根据OAuth的认证流程，用户授权凭证会由服务器转发到redirect_uri对应的地址。 如果攻击者伪造redirect_uri为自己的地址，然后诱导用户发送该请求，之后获取的凭证就会发送给攻击者伪造的回调地址，攻击者使用该凭证即可登录用户账号，造成授权劫持。 正常情况下，为了防止该情况出现，认证服务器会验证自己的client_id与回调地址是否对应，常见的方法是验证回调地址的主域。 以下几种情况验证配置不当，容易导致授权劫持： 未验证 未验证的情况，可以直接跳出外域。案例:土豆网某处认证缺陷可劫持oauth_token 验证绕过 auth.app.com.evil.com evil.com?auth.app.com evil.com?@auth.app.com 案例:腾讯OAuth平台 redirect_uri 过滤不严可能导致用户信息遭窃取（二） auth.app.com@evil.com 案例:绕过网易oauth认证的redirect_uri限制劫持帐号token auth.app.com\\@evil.com 案例:腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取（四） evil.com\\auth.app.com evil.com:\\auth.app.com evil.com\\.auth.app.com 案例:腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取 evil.com:\\@auth.app.com 案例:新浪微博OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取 宽字符绕过 案例: 腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取（三） 子域可控 对回调地址验证了主域为app.com，但其子域evil.app.com可被任意用户注册使用。案例:新浪微博部分App Oauth2漏洞 跨域 （1）利用可信域跳转盗取授权码。 如果网站存在任意跳转，如https://www.example.com/?return_url=，且未校验跳转后地址。可以构造如下向量： 1https://www.example.com/?return_url=https://www.evil.com 诱骗用户访问该链接，触发OAuth认证如下： 1https://www.example.com/oauth/authorize?client_id=xxx&amp;redirect_uri=https://www.example.com/?return_url=https://www.evil.com&amp;response_type=code&amp;state=xxx 用户授权之后，会继续跳转到https://www.evil.com，攻击者可以从referer头获取到授权码。 （2）利用可信域referer盗取授权码。 如果跳转后页面可控，比如可以插入自定义图片，或者存在xss漏洞，可以构造如下向量： 1&lt;img src=&quot;https://www.evil.com&quot;&gt; 用户授权之后，会向https://www.evil.com请求资源文件，攻击者可以从referer头获取到授权码。 scope越权访问案例:从“黑掉GITHUB”学WEB安全开发展示了scope权限控制不当带来的安全风险，同时将授权劫持的几个方面演绎的淋漓尽致。 缩写 CAS: Central Authentication Service, 中心认证服务 AS: Authorization Server, 授权服务器 RS: Resource Server, 资源服务器 SPA: Single Page Application, 单页应用 SSO: Single Sign On, 单点登录 OIDC: OpenID Connect, 开放身份连接 参考资料 rfc5849 - The OAuth 1.0 Protocol rfc6749 - The OAuth 2.0 Authorization Framework rfc6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage rfc6819 - OAuth 2.0 Threat Model and Security Considerations rfc7009 - OAuth 2.0 Token Revocation rfc7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants rfc7522 - Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants rfc7523 - JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants rfc7591 - OAuth 2.0 Dynamic Client Registration Protocol rfc7592 - OAuth 2.0 Dynamic Client Registration Management Protocol rfc7636 - Proof Key for Code Exchange by OAuth Public Clients rfc7662 - OAuth 2.0 Token Introspection rfc8252 - OAuth 2.0 for Native Apps rfc8414 - OAuth 2.0 Authorization Server Metadata rfc8628 - OAuth 2.0 Device Authorization Grant rfc8693 - OAuth 2.0 Token Exchange rfc8705 - OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens Security Best Current Practice OAuth 2.0 for Browser-Based Apps oauth.net 白话让你理解什么是oAuth2协议 OAuth 2.0攻击面与案例总结 OIDC &amp; OAuth2.0 协议及其授权模式详解 OAuth 2.0 的一个简单解释 OpenID Connect 关于作者更多内容请访问Pinohans Blog","categories":[{"name":"security","slug":"security","permalink":"https://pinohans.github.io/categories/security/"}],"tags":[{"name":"oauth2","slug":"oauth2","permalink":"https://pinohans.github.io/tags/oauth2/"},{"name":"pentest","slug":"pentest","permalink":"https://pinohans.github.io/tags/pentest/"},{"name":"bugbounty","slug":"bugbounty","permalink":"https://pinohans.github.io/tags/bugbounty/"},{"name":"security","slug":"security","permalink":"https://pinohans.github.io/tags/security/"}]},{"title":"Golang机制之CGO","slug":"Golang机制之CGO","date":"2023-03-03T11:00:00.000Z","updated":"2023-04-08T12:03:42.553Z","comments":true,"path":"2023/03/03/Golang机制之CGO/","link":"","permalink":"https://pinohans.github.io/2023/03/03/Golang%E6%9C%BA%E5%88%B6%E4%B9%8BCGO/","excerpt":"","text":"CGOTODO CGO的使用CGO的类型定义 C 语言类型 CGO 类型 Go 语言类型 char C.char byte singed char C.schar int8 unsigned char C.uchar uint8 short C.short int16 unsigned short C.ushort uint16 int C.int int32 unsigned int C.uint uint32 long C.long int32 unsigned long C.ulong uint32 long long int C.longlong int64 unsigned long long int C.ulonglong uint64 float C.float float32 double C.double float64 size_t C.size_t uint Golang系列文章其他相关内容请参考Golang深入浅出","categories":[{"name":"development","slug":"development","permalink":"https://pinohans.github.io/categories/development/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://pinohans.github.io/tags/golang/"}]},{"title":"Golang机制之Context","slug":"Golang机制之Context","date":"2023-03-02T06:00:00.000Z","updated":"2023-04-08T11:59:59.481Z","comments":true,"path":"2023/03/02/Golang机制之Context/","link":"","permalink":"https://pinohans.github.io/2023/03/02/Golang%E6%9C%BA%E5%88%B6%E4%B9%8BContext/","excerpt":"","text":"ContextGo 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、key-value等。随着 context 包的引入，标准库中很多接口因此加上了 context 参数，context 几乎成为了并发控制和超时控制的标准做法。 Context的使用Context以Background为根，通过WithValue、WithCancel、WithDeadline、WithTimeout等方法创建子Context，形成一棵树状结构。 子Context可以继承父Context的属性，也可以单独设置属性。 一旦某个Context被取消，它的子Context都会被取消。 Context的定义1234567891011121314type Context interface &#123; // 一般用于select语句中，用于监听上下文的取消或超时 // 当上下文被取消或超时，返回一个关闭的chan，只有此时才能从chan中读取到零数据 Done() &lt;-chan struct&#123;&#125; // 返回上下文被取消或超时的原因，如果上下文没有被取消或超时，返回nil Err() error // 返回上下文的截止时间，如果上下文没有截止时间，ok返回false Deadline() (deadline time.Time, ok bool) // 返回上下文存储的key-value，如果上下文没有存key，则value返回nil Value(key any) any&#125; Context的创建Context 有两个方法用于创建： 12345// 返回一个空的Context，它永远不会被取消，也不会超时，用于最上层创建func Background() Context// 返回一个空的Context，当不确定使用哪个Context时，使用TODOfunc TODO() Context Context的衍生Context 有四个方法用于衍生： 123456789101112131415// 传入父Context，返回一个子Context和一个取消函数// 当调用cancel函数时，该子Context及后代Context都会被取消func WithCancel(parent Context) (ctx Context, cancel CancelFunc)// 传入父Context和截止时间，返回一个子Context和一个取消函数// 当调用cancel函数或超时，该子Context及后代Context都会被取消func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)// 传入父Context和超时时间，返回一个子Context和一个取消函数// 当调用cancel函数或超时，该子Context及后代Context都会被取消func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)// 传入父Context和key-value，返回一个子Context// 该子Context继承父Context的属性，同时单独设置key-valuefunc WithValue(parent Context, key, val any) Context go1.20新增了一个WithCancel的变体WithCancelCause： 123// 传入父Context，返回一个子Context和一个带错误的取消函数// 当调用cancel函数时，该子Context及后代Context都会被取消func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) Context的取消直接调用 cancel 函数，或者触发超时， Context 都会被取消。 12// 取消函数type CancelFunc func() go1.20新增了一个带错误的取消函数CancelCauseFunc： 12// 带错误的取消函数type CancelCauseFunc func(error) Context的监听Context 通常使用 select 语句监听 Done 信号： 12345678func watch(ctx context.Context) error &#123; for &#123; select &#123; case &lt;-ctx.Done(): return ctx.Err() &#125; &#125;&#125; go1.20新增了一个获得Context取消原因的方法Cause： 12// 获得Context取消原因，当CancelCauseFunc被调用时，返回传入的error，否则和Err()返回一致func Cause(c Context) error Context 使用原则在golang文档里面，对于 Context 的使用有一些原则： Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx. Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines. 不要把 Context 放在结构体中，要以参数的方式传递。Context 应该作为第一个参数，一般命名为 ctx。 不要传递一个 nil 的 Context，即使函数允许 nil 也不要这么做。如果不确定使用哪个 Context，使用 context.TODO。 使用 Context 的 Value 在进程和 API 之间传递请求作用域数据，不要用于传递可选参数给函数。 相同的 Context 可以传递给不同的 goroutine，Context 是安全的，可以被多个 goroutine 同时使用。 Golang系列文章其他相关内容请参考Golang深入浅出 参考资料 context package - context - Go Packages Golang 中 context 的使用方式 深度解密Go语言之context","categories":[{"name":"development","slug":"development","permalink":"https://pinohans.github.io/categories/development/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://pinohans.github.io/tags/golang/"}]},{"title":"Golang深入浅出","slug":"Golang深入浅出","date":"2023-03-01T06:00:00.000Z","updated":"2023-04-08T13:35:46.348Z","comments":true,"path":"2023/03/01/Golang深入浅出/","link":"","permalink":"https://pinohans.github.io/2023/03/01/Golang%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/","excerpt":"","text":"GOTODO Go 1.19 [范型]增加范型支持 [文档]支持链接、列表和更清晰的标题语法 [内存]Go 的内存模型现在明确定义了sync&#x2F;atomic 包的行为 [安全]os&#x2F;exec 包不再考虑 PATH 查找中的相对路径 [GC]垃圾收集器增加了对软内存限制的支持 GO基础函数传值 When are function parameters passed by value? As in all languages in the C family, everything in Go is passed by value. That is, a function always gets a copy of the thing being passed, as if there were an assignment statement assigning the value to the parameter. For instance, passing an int value to a function makes a copy of the int, and passing a pointer value makes a copy of the pointer, but not the data it points to. (See a later section for a discussion of how this affects method receivers.) Map and slice values behave like pointers: they are descriptors that contain pointers to the underlying map or slice data. Copying a map or slice value doesn’t copy the data it points to. Copying an interface value makes a copy of the thing stored in the interface value. If the interface value holds a struct, copying the interface value makes a copy of the struct. If the interface value holds a pointer, copying the interface value makes a copy of the pointer, but again not the data it points to. 什么时候函数参数是按值传递的？ 和 C 语言一样，Go 中的所有东西都是按值传递的。也就是说，函数总是会得到传递的东西的副本，就像有一个赋值语句将值赋给参数一样。例如，将 int 值传递给函数会复制 int，将指针值传递给函数会复制指针，但不会复制它指向的数据。（关于这个问题的后续部分会讨论方法接收者的影响。） Map 和 slice 值的行为类似于指针：它们是描述符，包含指向底层 map 或 slice 数据的指针。复制 map 或 slice 值不会复制它们指向的数据。复制接口值会复制存储在接口值中的东西。如果接口值包含一个结构体，复制接口值会复制结构体。如果接口值包含一个指针，复制接口值会复制指针，但是不会复制它指向的数据。 值类型：int、float、bool、string、array、sturct等 引用类型：slice，map，channel，interface，func等 关键词之returnGo函数返回有两种方式： 第一种方式，直接返回，返回值的类型和个数必须和函数定义的返回值类型和个数一致。 第二种方式，直接return，返回值在函数体内计算好后，直接return，不需要指定返回值的变量名，初始为0值。 如果return后跟随返回变量或值，那么将忽略函数定义中的返回值变量。 12345678910111213func f1() (int) &#123; return 1 // 1&#125;func f2() (a int) &#123; a = 1 return // 1&#125;func f3() (a int) &#123; a = 1 return 2 // 2&#125; 注意，两种return和defer的执行顺序为return 1 -&gt; defer -&gt; return，故以下代码返回值不同： 123456789101112131415func f4() (a int) &#123; a = 1 defer func() &#123; a++ &#125;() return // 2&#125;func f5() int &#123; var a = 1 defer func() &#123; a++ &#125;() return a // 1&#125; 关键词之deferdefer执行顺序为栈顺序LIFO，即后进先出。 12345678func Defer() &#123; defer func() &#123; println(&quot;defer1&quot;) &#125;() defer func() &#123; println(&quot;defer2&quot;) &#125;()&#125; 注意，两种return和defer的执行顺序为return 1 -&gt; defer -&gt; return，参考“关键词之return”的例子。 GO机制Contextcontext 包定义了 Context 类型，它可以携带超时时间、取消信号、和其他请求作用域的key-value对，用于 API 和进程之间传递。 通常用于控制 goroutine 的生命周期，比如控制 goroutine 的取消、超时、截止时间等。 Golang机制之Context CGOCGO 是 C 语言和 Go 语言的桥梁，它允许 Go 调用 C 语言的库，也允许 Go 被 C 语言调用。 Golang机制之CGO 参考资料 Frequently Asked Questions (FAQ)","categories":[{"name":"development","slug":"development","permalink":"https://pinohans.github.io/categories/development/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://pinohans.github.io/tags/golang/"}]},{"title":"安全名词释义","slug":"安全名词释义","date":"2023-02-01T04:14:48.000Z","updated":"2023-04-03T04:36:43.961Z","comments":true,"path":"2023/02/01/安全名词释义/","link":"","permalink":"https://pinohans.github.io/2023/02/01/%E5%AE%89%E5%85%A8%E5%90%8D%E8%AF%8D%E9%87%8A%E4%B9%89/","excerpt":"","text":"网络安全 缩写 全拼 翻译 释义 AntiVirus anti-virus software 防病毒保护 EPP endpoint protection platform 端点防护平台 EDR endpoint detection and response 端点检测和响应 Antivirus防病毒保护是最常见的端点安全类型，尤其是在消费电子产品中。有些设备预装了防病毒软件，但也有供应商提供高级解决方案以提供更高级的保护。典型的防病毒软件会扫描用户的计算机以查找恶意软件，例如蠕虫、特洛伊木马、广告软件、勒索软件等。它通过使用三种类型的检测来实现这一点： 签名比较：监控设备以获取已知威胁的证据并阻止它们采取进一步行动； 启发式分析：通过将新程序与启发式数据库中已知的病毒进行比较，检查新程序的可疑源代码或行为； 完整性检查：检查系统文件是否有损坏的证据。 一些防病毒供应商支持人工智能 (AI) 和机器学习，但很多供应商不支持。这些高级功能对于保护端点免受经常试图破坏业务数据的各种复杂威胁至关重要。 EPP端点保护平台 (EPP) 通常包括防病毒工具，同时还提供一些额外的关键功能。首先，它添加了机器学习来支持行为分析，从而将传统威胁监控扩展到已知威胁之外。除了更常见的攻击之外，此功能还允许 EPP防止未知攻击。EPP 还会验证妥协指标 (IoC) 并监控设备的内存，以识别内存消耗中的不规则模式。 EPP优于基本的防病毒保护，适用于大公司的广泛端点管理和威胁预防，但一些复杂的攻击仍然能够逃避检测。还值得注意的是，虽然 EPP 可用于识别漏洞和防止攻击，但它不会采取措施消除通过您的端点前进的活动威胁。这就是为什么它经常与 EDR 解决方案结合以创建多层安全系统。 EDR端点检测和响应 (EDR) 代表最新和最先进的端点保护层。它扩展了对 AI、机器学习、威胁情报和行为分析的典型 EPP 支持，以创建可主动消除攻击的解决方案。如果 EPP 是一面盾牌，那么 EDR 就是一把剑。为此，EDR 系统从网络中的端点收集和分析数据，以便阻止攻击的发生。一旦威胁被消除，EDR 就可以用来追踪攻击的确切来源，这样就可以在未来防止类似的事件发生。 EDR 充当组织端点网络范围内的集中管理中心。它可以在检测到最早迹象时阻止攻击，甚至在人类管理员得知威胁存在之前。EPP 是提供被动威胁防御的第一道防线，而 EDR 会在网络攻击造成重大损害之前主动减轻网络攻击。 参考资料 Antivirus vs. EPP vs. EDR: How to Secure Your Endpoints","categories":[{"name":"security","slug":"security","permalink":"https://pinohans.github.io/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"https://pinohans.github.io/tags/security/"}]},{"title":"应急响应中心src经验与记录","slug":"应急响应中心src经验与记录","date":"2023-01-01T00:00:00.000Z","updated":"2023-04-03T04:15:20.527Z","comments":true,"path":"2023/01/01/应急响应中心src经验与记录/","link":"","permalink":"https://pinohans.github.io/2023/01/01/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BF%83src%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%AE%B0%E5%BD%95/","excerpt":"","text":"工具 burpsuite一款强大的web安全测试工具 ARL(Asset Reconnaissance Lighthouse)资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面 src列表 厂商 链接 id 腾讯 https://security.tencent.com/ pinohans 滴滴 https://sec.didichuxing.com/ pinohans 字节跳动 https://security.bytedance.com/ 京东 https://security.jd.com/ 百度 https://bsrc.baidu.com/ 360 https://security.360.cn/ 理想 https://security.lixiang.com/ 美团 https://security.meituan.com/ 荣耀 https://security.hihonor.com/ 快手 https://security.kuaishou.com/ OPPO https://security.oppo.com/ 阿里巴巴 https://security.alibaba.com/ 顺丰 https://sfsrc.sf-express.com/ 中通 https://sec.zto.com/ 自如 https://zrsecurity.ziroom.com/ 平安 https://security.pingan.com/ 微博 https://wsrc.weibo.com/ 一起教育 https://security.17zuoye.com/ 金山 https://security.wps.cn/ 看云 https://security.yuanfudao.com/ 华米 https://src.zepp.com/ 小赢ying https://security.xiaoying.com/ 麦当劳 https://security.mcd.cn/ 58同城 https://security.58.com/ vivo https://security.vivo.com.cn/ 爱奇艺 https://security.iqiyi.com/ bilibili https://security.bilibili.com/ 东方财富 https://security.eastmoney.com/ 大疆 https://security.dji.com/ 途虎 https://security.tuhu.cn/ 喜马拉雅 https://security.ximalaya.com/ 陌陌 https://security.immomo.com/ 深信服 https://security.sangfor.com.cn/ 宜信 https://security.creditease.cn/ 合合 https://security.intsig.com/ 斗鱼 https://security.douyu.com/ 海康威视 https://www.hikvision.com/cn/support/CybersecurityCenter/ 小鹏 https://security.xiaopeng.com/ Boss直聘 https://src.zhipin.com/ 携程 https://sec.ctrip.com/ 完美世界 https://security.wanmei.com/ 法大大 https://sec.fadada.com/ 贝壳 https://security.ke.com/ 东航 https://src.ceair.com/ 蚂蚁 https://security.alipay.com/ 银联 https://security.unionpay.com/ 富途 https://ftsrc.futunn.com/ 持安 https://security.chiansec.com/ 迅雷 https://security.xunlei.com/ 猪八戒 https://security.zbj.com/ TCL https://src.tcl.com/ 焦点 https://security.focuschina.com/ T3 https://security.t3go.cn/ soul https://security.soulapp.cn/ 众安 https://security.zhongan.com/ 唯品会 https://sec.vip.com/ 瓜子二手车 https://security.guazi.com/ 爱世博 https://security.acb.bet/ 贝锐 https://security.oray.com/ 马蜂窝 https://security.mafengwo.cn/ 有赞 https://src.youzan.com/ 美丽联合 https://security.mogu.com/ 水滴 https://security.shuidihuzhu.com/ 知识星球 https://security.zsxq.com/ 360数科 https://security.360sk.com/ 统信 https://src.uniontech.com/ 猎聘 https://security.liepin.com/ 竞技世界 https://security.jj.cn/ 去哪儿网 https://security.qunar.com/ 魅族 https://sec.meizu.com/ vipkid https://security.vipkid.com.cn/ 融360 https://security.rong360.com/ 虎牙ya https://security.huya.com/ 酷狗 https://security.kugou.com/ YY https://security.yy.com/ 智联 https://src.zhaopin.com/ 多点 https://src.dmall.com/ DHgate https://dhsrc.dhgate.com/ 小米 https://sec.xiaomi.com/ 网易 https://aq.163.com/ 安恒 https://security.dbappsecurity.com.cn/ 菜鸟 https://sec.cainiao.com/ 天融信 https://src.topsec.com.cn/ 其他安全平台 厂商 链接 关键基础设施安全应急响应中心 https://www.ics-cert.org.cn/","categories":[{"name":"bugbounty","slug":"bugbounty","permalink":"https://pinohans.github.io/categories/bugbounty/"}],"tags":[{"name":"bugbounty","slug":"bugbounty","permalink":"https://pinohans.github.io/tags/bugbounty/"},{"name":"security","slug":"security","permalink":"https://pinohans.github.io/tags/security/"}]}],"categories":[{"name":"security","slug":"security","permalink":"https://pinohans.github.io/categories/security/"},{"name":"development","slug":"development","permalink":"https://pinohans.github.io/categories/development/"},{"name":"bugbounty","slug":"bugbounty","permalink":"https://pinohans.github.io/categories/bugbounty/"}],"tags":[{"name":"oauth2","slug":"oauth2","permalink":"https://pinohans.github.io/tags/oauth2/"},{"name":"pentest","slug":"pentest","permalink":"https://pinohans.github.io/tags/pentest/"},{"name":"bugbounty","slug":"bugbounty","permalink":"https://pinohans.github.io/tags/bugbounty/"},{"name":"security","slug":"security","permalink":"https://pinohans.github.io/tags/security/"},{"name":"golang","slug":"golang","permalink":"https://pinohans.github.io/tags/golang/"}]}